from fastapi import APIRouter, HTTPException, Request, Response
from utils.firebase import db
from database.models.playlist import Playlist
from pydantic import BaseModel
from utils import spotify
from fastapi.responses import JSONResponse
import spotipy
from typing import Optional 
import base64
from utils.ai_model import AIModel
from database.models.user import User
   
class Song(BaseModel):
    title: str
    artist: str
    
class PlaylistInput(BaseModel):
    name: str
    artist: str
    album: str
    image: str
    uri: str
class PlaylistInputTracks(BaseModel):
    songs: list[PlaylistInput]

   
router = APIRouter()

# Process query string, feed into langchain, get list of tracks.
@router.post("/search")
def show_playlist(prompt: str, request: Request, response: Response):
    access_token = request.cookies.get("access_token")
    refresh_token = request.cookies.get("refresh_token")
    
    if not access_token or not refresh_token:
        raise HTTPException(status_code=400, detail="Authentication required")
    
    sp = spotify.get_spotify_client(access_token) 
    
    # use sp instance to get current user, use that id to get users quiz answers.
    try:
        current_user = sp.me()
    except spotipy.exceptions.SpotifyException as e:
        if e.http_status == 401: 
            new_token = spotify.refresh_token(refresh_token)
            if not new_token:
                raise HTTPException(status_code=400, detail="Authentication required, login again")

            response.set_cookie(key="access_token", value=new_token['access_token'])
            response.set_cookie(key="refresh_token", value=new_token['refresh_token'])
            sp = spotify.get_spotify_client(new_token["access_token"]) 

            current_user = sp.me()
    
    current_user_id = current_user["id"]
    user_info: User = db.collection("users").document(current_user_id).get()
    
    if not user_info.exists:
        raise HTTPException(status_code=400, detail="User not found")
    else:
        user = User.from_dict(user_info.to_dict())
        quiz_answers = user.quiz_answers
        
    try:
        model = AIModel(quiz_answers, prompt)
        playlist_tracks = model.get_playlist()
    except Exception as e:
        raise HTTPException(status_code=400, detail="Error getting playlist from AI model")
    
    gen_playlist = playlist_tracks["playlist"]
    gen_description = playlist_tracks["description"]
        
    playlist_tracks = []
    
    for track in gen_playlist:
        search_query = f"track:{track['title']} artist:{track['artist']}"
        
        try:
            searched_track = sp.search(q=search_query, limit=1, type="track")  
            
        except spotipy.exceptions.SpotifyException as e:
            raise HTTPException(status_code=400, detail="Error searching for track")
      
        if not searched_track:
            continue
        
        if searched_track and searched_track["tracks"]["items"]:
            track_model = {
                "name": searched_track["tracks"]["items"][0]["name"],
                "artist": searched_track["tracks"]["items"][0]["artists"][0]["name"],
                "album": searched_track["tracks"]["items"][0]["album"]["name"],
                "image": searched_track["tracks"]["items"][0]["album"]["images"][2]["url"],
                "uri": searched_track["tracks"]["items"][0]["uri"]
            }
            playlist_tracks.append(track_model) 
    
    return JSONResponse(content={"songs": playlist_tracks, "description": gen_description})

# create the actual paylist
@router.post("/create")
def create_playlist(songs: PlaylistInputTracks, request: Request, response: Response,playlist_name: str, image: Optional[str] | None = None, query:str | None = None):

    access_token = request.cookies.get("access_token")
    refresh_token = request.cookies.get("refresh_token")
    
    if not access_token or not refresh_token:
        raise HTTPException(status_code=400, detail="Authentication required")
    
    sp = spotify.get_spotify_client(access_token)
    
    try:
        current_user = sp.me()
    except spotipy.exceptions.SpotifyException as e:
        if e.http_status == 401: 
            new_token = spotify.refresh_token(refresh_token)
            if not new_token:
                raise HTTPException(status_code=400, detail="Authentication required, login again")

            response.set_cookie(key="access_token", value=new_token['access_token'])
            response.set_cookie(key="refresh_token", value=new_token['refresh_token'])
            sp = spotify.get_spotify_client(new_token["access_token"]) 

            current_user = sp.me()
            
    current_user_id = current_user["id"]
    
    try:
        new_playlist = sp.user_playlist_create(current_user_id, name=playlist_name, public=True, collaborative=False, description="Generated by MoodMusic")
        songs = [song.model_dump() for song in songs.songs]
        song_uris = [song["uri"] for song in songs]
        if song_uris:
            sp.playlist_add_items(new_playlist["id"], song_uris)
        else:
            raise HTTPException(status_code=400, detail="No songs added to playlist")
        
    except spotipy.exceptions.SpotifyException as e:
        raise HTTPException(status_code=400, detail="Error creating playlist")
    
    if image:
        image_data = base64.b64decode(image)
        try:
            sp.playlist_upload_cover_image(new_playlist["id"], image_data)
        except spotipy.exceptions.SpotifyException as e:
            raise HTTPException(status_code=400, detail="Error uploading cover image")
      
    user_ref = db.collection("users").document(current_user_id)
    playlist_ref = user_ref.collection("playlists").document(new_playlist["id"])
    created_playlist = Playlist(name=playlist_name, query=query, timecreated=None)
    playlist_ref.set(created_playlist.to_dict())
    
    return JSONResponse(content={"message": "Playlist created successfully", "playlist": new_playlist})

    
   



